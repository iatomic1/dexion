// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: telegram.sql

package repository

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createTelegramUser = `-- name: CreateTelegramUser :one
INSERT INTO telegram_users (chat_id, username)
VALUES ($1, $2)
ON CONFLICT (chat_id) DO UPDATE SET
  username = EXCLUDED.username
RETURNING chat_id, username, created_at
`

type CreateTelegramUserParams struct {
	ChatID   string  `json:"chatId"`
	Username *string `json:"username"`
}

func (q *Queries) CreateTelegramUser(ctx context.Context, arg CreateTelegramUserParams) (*TelegramUser, error) {
	row := q.db.QueryRow(ctx, createTelegramUser, arg.ChatID, arg.Username)
	var i TelegramUser
	err := row.Scan(&i.ChatID, &i.Username, &i.CreatedAt)
	return &i, err
}

const getTelegramUser = `-- name: GetTelegramUser :one
SELECT chat_id, username, created_at FROM telegram_users
WHERE chat_id = $1
`

func (q *Queries) GetTelegramUser(ctx context.Context, chatID string) (*TelegramUser, error) {
	row := q.db.QueryRow(ctx, getTelegramUser, chatID)
	var i TelegramUser
	err := row.Scan(&i.ChatID, &i.Username, &i.CreatedAt)
	return &i, err
}

const getTrackedWalletsTelegram = `-- name: GetTrackedWalletsTelegram :many
SELECT w.address, tuw.nickname, w.created_at
FROM telegram_user_wallets tuw
JOIN wallets w ON tuw.wallet_address = w.address
WHERE tuw.chat_id = $1
`

type GetTrackedWalletsTelegramRow struct {
	Address   string             `binding:"required" example:"SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1" json:"address"`
	Nickname  string             `json:"nickname"`
	CreatedAt pgtype.Timestamptz `json:"createdAt"`
}

func (q *Queries) GetTrackedWalletsTelegram(ctx context.Context, chatID string) ([]*GetTrackedWalletsTelegramRow, error) {
	rows, err := q.db.Query(ctx, getTrackedWalletsTelegram, chatID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetTrackedWalletsTelegramRow
	for rows.Next() {
		var i GetTrackedWalletsTelegramRow
		if err := rows.Scan(&i.Address, &i.Nickname, &i.CreatedAt); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const isTrackingWalletTelegram = `-- name: IsTrackingWalletTelegram :one
SELECT EXISTS(
  SELECT 1 FROM telegram_user_wallets
  WHERE chat_id = $1 AND wallet_address = $2
)
`

type IsTrackingWalletTelegramParams struct {
	ChatID        string `json:"chatId"`
	WalletAddress string `json:"walletAddress"`
}

func (q *Queries) IsTrackingWalletTelegram(ctx context.Context, arg IsTrackingWalletTelegramParams) (bool, error) {
	row := q.db.QueryRow(ctx, isTrackingWalletTelegram, arg.ChatID, arg.WalletAddress)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const trackWalletTelegram = `-- name: TrackWalletTelegram :one
INSERT INTO telegram_user_wallets (chat_id, wallet_address, nickname)
VALUES ($1, $2, $3)
RETURNING chat_id, wallet_address, nickname, created_at
`

type TrackWalletTelegramParams struct {
	ChatID        string `json:"chatId"`
	WalletAddress string `json:"walletAddress"`
	Nickname      string `json:"nickname"`
}

func (q *Queries) TrackWalletTelegram(ctx context.Context, arg TrackWalletTelegramParams) (*TelegramUserWallet, error) {
	row := q.db.QueryRow(ctx, trackWalletTelegram, arg.ChatID, arg.WalletAddress, arg.Nickname)
	var i TelegramUserWallet
	err := row.Scan(
		&i.ChatID,
		&i.WalletAddress,
		&i.Nickname,
		&i.CreatedAt,
	)
	return &i, err
}

const untrackWalletTelegram = `-- name: UntrackWalletTelegram :exec
DELETE FROM telegram_user_wallets
WHERE chat_id = $1 AND wallet_address = $2
`

type UntrackWalletTelegramParams struct {
	ChatID        string `json:"chatId"`
	WalletAddress string `json:"walletAddress"`
}

func (q *Queries) UntrackWalletTelegram(ctx context.Context, arg UntrackWalletTelegramParams) error {
	_, err := q.db.Exec(ctx, untrackWalletTelegram, arg.ChatID, arg.WalletAddress)
	return err
}

const upsertTelegramUserWallet = `-- name: UpsertTelegramUserWallet :one
WITH wallet AS (
  INSERT INTO wallets (address)
  VALUES ($2)
  ON CONFLICT (address) DO NOTHING
  RETURNING address
)
INSERT INTO telegram_user_wallets (chat_id, wallet_address, nickname)
VALUES ($1, $2, $3)
ON CONFLICT (chat_id, wallet_address)
DO UPDATE SET
  nickname = EXCLUDED.nickname
RETURNING chat_id, wallet_address, nickname, created_at
`

type UpsertTelegramUserWalletParams struct {
	ChatID        string `json:"chatId"`
	WalletAddress string `json:"walletAddress"`
	Nickname      string `json:"nickname"`
}

func (q *Queries) UpsertTelegramUserWallet(ctx context.Context, arg UpsertTelegramUserWalletParams) (*TelegramUserWallet, error) {
	row := q.db.QueryRow(ctx, upsertTelegramUserWallet, arg.ChatID, arg.WalletAddress, arg.Nickname)
	var i TelegramUserWallet
	err := row.Scan(
		&i.ChatID,
		&i.WalletAddress,
		&i.Nickname,
		&i.CreatedAt,
	)
	return &i, err
}
