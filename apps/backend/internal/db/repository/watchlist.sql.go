// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: watchlist.sql

package repository

import (
	"context"

	"github.com/google/uuid"
)

const createWatchlist = `-- name: CreateWatchlist :one
INSERT INTO watchlist (
   id, ca, user_id
) VALUES (
   uuid_generate_v4(), $1, $2
)
RETURNING id, ca, user_id, updated_at, created_at
`

type CreateWatchlistParams struct {
	Ca     string  `binding:"required" example:"SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.velar-token" json:"ca"`
	UserID *string `json:"userId"`
}

func (q *Queries) CreateWatchlist(ctx context.Context, arg CreateWatchlistParams) (*Watchlist, error) {
	row := q.db.QueryRow(ctx, createWatchlist, arg.Ca, arg.UserID)
	var i Watchlist
	err := row.Scan(
		&i.ID,
		&i.Ca,
		&i.UserID,
		&i.UpdatedAt,
		&i.CreatedAt,
	)
	return &i, err
}

const deleteWatchlist = `-- name: DeleteWatchlist :exec
DELETE FROM watchlist
WHERE id = $1 AND user_id = $2
`

type DeleteWatchlistParams struct {
	ID     uuid.UUID `json:"id"`
	UserID *string   `json:"userId"`
}

func (q *Queries) DeleteWatchlist(ctx context.Context, arg DeleteWatchlistParams) error {
	_, err := q.db.Exec(ctx, deleteWatchlist, arg.ID, arg.UserID)
	return err
}

const getWatchlistsByUserId = `-- name: GetWatchlistsByUserId :many
SELECT id, ca, user_id, updated_at, created_at FROM watchlist
WHERE user_id = $1
`

func (q *Queries) GetWatchlistsByUserId(ctx context.Context, userID *string) ([]*Watchlist, error) {
	rows, err := q.db.Query(ctx, getWatchlistsByUserId, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Watchlist
	for rows.Next() {
		var i Watchlist
		if err := rows.Scan(
			&i.ID,
			&i.Ca,
			&i.UserID,
			&i.UpdatedAt,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const hasWatchlist = `-- name: HasWatchlist :one
SELECT EXISTS (
  SELECT 1 FROM watchlist
  WHERE ca = $1 AND user_id = $2
)
`

type HasWatchlistParams struct {
	Ca     string  `binding:"required" example:"SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.velar-token" json:"ca"`
	UserID *string `json:"userId"`
}

func (q *Queries) HasWatchlist(ctx context.Context, arg HasWatchlistParams) (bool, error) {
	row := q.db.QueryRow(ctx, hasWatchlist, arg.Ca, arg.UserID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const hasWatchlistById = `-- name: HasWatchlistById :one
SELECT EXISTS (
  SELECT 1 FROM watchlist
  WHERE id = $1 AND user_id = $2
)
`

type HasWatchlistByIdParams struct {
	ID     uuid.UUID `json:"id"`
	UserID *string   `json:"userId"`
}

func (q *Queries) HasWatchlistById(ctx context.Context, arg HasWatchlistByIdParams) (bool, error) {
	row := q.db.QueryRow(ctx, hasWatchlistById, arg.ID, arg.UserID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}
